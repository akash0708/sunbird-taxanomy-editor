import { useState } from 'react';
import {
  autoFillCodeFromName,
  autoGenerateDescriptionFromName,
} from '@/utils/HelperService';
import { batchCreateTerms, retryCreateTerm } from '@/services/termService';
import { Category } from '@/interfaces/CategoryInterface';
import { Framework } from '@/interfaces/FrameworkInterface';

interface TermFormState {
  name: string;
  code: string;
  description: string;
  label: string;
  selectedCategory: string;
}

interface BatchStatus {
  name: string;
  code: string;
  description: string;
  label: string;
  categoryCode: string;
  status: 'success' | 'failed' | 'pending';
  message: string;
}

interface ModalStatus {
  name: string;
  code: string;
  description: string;
  label: string;
  categoryCode: string;
  status: 'pending' | 'success' | 'failed';
  message?: string;
}

export function useStepTerms(
  categories: Category[],
  setCategories: (categories: Category[]) => void,
  framework: Partial<Framework> | null
) {
  const [form, setForm] = useState<TermFormState>({
    name: '',
    code: '',
    description: '',
    label: '',
    selectedCategory: '',
  });
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [pendingTerms, setPendingTerms] = useState<
    Omit<BatchStatus, 'status' | 'message'>[]
  >([]);
  const [batchStatus, setBatchStatus] = useState<BatchStatus[]>([]);
  const [modalOpen, setModalOpen] = useState(false);
  const [modalStatuses, setModalStatuses] = useState<ModalStatus[]>([]);
  const [currentModalIndex, setCurrentModalIndex] = useState<number>(0);

  // Autofill code, description, label when name changes
  const handleFormChange = (
    e:
      | React.ChangeEvent<HTMLInputElement>
      | React.ChangeEvent<{ value: unknown }>
      | import('@mui/material/Select').SelectChangeEvent<string>
  ) => {
    const target = e.target as
      | HTMLInputElement
      | { name?: string; value: unknown };
    const name = target.name || '';
    const value = target.value;
    let updatedForm = { ...form, [name]: value };
    if (name === 'name') {
      updatedForm = autoFillCodeFromName(updatedForm, value as string);
      updatedForm.description = autoGenerateDescriptionFromName(
        value as string
      );
      updatedForm.label = value as string;
    }
    setForm(updatedForm);
  };

  // Add term to local pending list
  const handleAddTerm = (e: React.FormEvent) => {
    e.preventDefault();
    if (!form.selectedCategory) {
      setError('Please select a category');
      return;
    }
    const selectedCategory = categories.find(
      (cat) => cat.code === form.selectedCategory
    );
    if (!selectedCategory) {
      setError('Selected category not found');
      return;
    }
    setPendingTerms((prev) => [
      ...prev,
      {
        name: form.name,
        code: form.code,
        description: form.description,
        label: form.label,
        categoryCode: form.selectedCategory,
      },
    ]);
    setForm({
      name: '',
      code: '',
      description: '',
      label: '',
      selectedCategory: '',
    });
    setError(null);
    setSuccess(null);
  };

  // Batch create terms with modal
  const handleBatchCreate = async () => {
    setModalOpen(true);
    setBatchStatus([]);
    setModalStatuses(
      pendingTerms.map((term) => ({
        ...term,
        status: 'pending',
      }))
    );
    setCurrentModalIndex(0);
    const frameworkCode = framework?.code;
    if (!frameworkCode) {
      setModalStatuses(
        pendingTerms.map((term) => ({
          ...term,
          status: 'failed',
          message: 'Missing framework code',
        }))
      );
      setTimeout(() => {
        setModalOpen(false);
        setBatchStatus(
          pendingTerms.map((term) => ({
            ...term,
            status: 'failed',
            message: 'Missing framework code',
          })) as BatchStatus[]
        );
        setPendingTerms([]);
      }, 1200);
      return;
    }
    const results = await batchCreateTerms(pendingTerms, frameworkCode);
    // Update store for successful terms
    results.forEach((res, i) => {
      setCurrentModalIndex(i);
      if (res.status === 'success') {
        const categoryIndex = categories.findIndex(
          (cat) => cat.code === res.term.categoryCode
        );
        if (categoryIndex !== -1) {
          const newTerm = {
            identifier: res.term.code,
            name: res.term.name,
            code: res.term.code,
            description: res.term.description,
            status: 'Live',
            label: res.term.label,
          };
          const updatedCategories = [...categories];
          if (!updatedCategories[categoryIndex].terms) {
            updatedCategories[categoryIndex].terms = [];
          }
          updatedCategories[categoryIndex].terms!.push(newTerm);
          setCategories(updatedCategories);
        }
      }
    });
    setTimeout(() => {
      setModalOpen(false);
      setBatchStatus(
        results.map((res) => ({
          name: res.term.name,
          code: res.term.code,
          description: res.term.description,
          label: res.term.label,
          categoryCode: res.term.categoryCode,
          status: res.status,
          message: res.message,
        })) as BatchStatus[]
      );
      setPendingTerms([]);
    }, 1200);
  };

  // Retry a single failed term creation
  const handleRetry = async (idx: number) => {
    if (!batchStatus[idx]) return;
    const term = batchStatus[idx];
    setBatchStatus((prev) =>
      prev.map((item, i) =>
        i === idx ? { ...item, status: 'pending', message: '' } : item
      )
    );
    const frameworkCode = framework?.code;
    if (!frameworkCode) {
      setBatchStatus((prev) =>
        prev.map((item, i) =>
          i === idx
            ? {
                ...item,
                status: 'failed',
                message: 'Missing framework code',
              }
            : item
        )
      );
      return;
    }
    try {
      await retryCreateTerm(
        {
          name: term.name,
          code: term.code,
          description: term.description,
          label: term.label,
          categoryCode: term.categoryCode,
        },
        frameworkCode
      );
      // Add term to the store
      const categoryIndex = categories.findIndex(
        (cat) => cat.code === term.categoryCode
      );
      if (categoryIndex !== -1) {
        const newTerm = {
          identifier: term.code,
          name: term.name,
          code: term.code,
          description: term.description,
          status: 'Live',
          label: term.label,
        };
        const updatedCategories = [...categories];
        if (!updatedCategories[categoryIndex].terms) {
          updatedCategories[categoryIndex].terms = [];
        }
        updatedCategories[categoryIndex].terms!.push(newTerm);
        setCategories(updatedCategories);
      }
      setBatchStatus((prev) =>
        prev.map((item, i) =>
          i === idx
            ? { ...item, status: 'success', message: 'Successfully created' }
            : item
        )
      );
    } catch (err: unknown) {
      let msg = 'Failed to create term';
      if (err instanceof Error) msg = err.message;
      setBatchStatus((prev) =>
        prev.map((item, i) =>
          i === idx ? { ...item, status: 'failed', message: msg } : item
        )
      );
    }
  };

  const hasUnsavedTerms = () => pendingTerms.length > 0 || false;

  return {
    form,
    setForm,
    error,
    setError,
    success,
    setSuccess,
    pendingTerms,
    setPendingTerms,
    batchStatus,
    setBatchStatus,
    modalOpen,
    setModalOpen,
    modalStatuses,
    setModalStatuses,
    currentModalIndex,
    setCurrentModalIndex,
    handleFormChange,
    handleAddTerm,
    handleBatchCreate,
    handleRetry,
    hasUnsavedTerms,
  };
}
