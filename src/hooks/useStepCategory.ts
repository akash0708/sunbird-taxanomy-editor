import { useState } from 'react';
import {
  autoFillCodeFromName,
  autoGenerateDescriptionFromName,
} from '@/utils/HelperService';
import {
  batchCreateCategories,
  retryCreateCategory,
  CategoryInput,
} from '@/services/categoryService';
import { Category } from '@/interfaces/CategoryInterface';
import { Framework } from '@/interfaces/FrameworkInterface';

interface BatchStatus {
  name: string;
  code: string;
  description: string;
  status: 'success' | 'failed' | 'pending';
  message: string;
}

interface ModalStatus {
  name: string;
  code: string;
  description: string;
  status: 'pending' | 'success' | 'failed';
  message?: string;
}

export function useStepCategory(
  categories: Category[],
  setCategories: (categories: Category[]) => void,
  framework: Partial<Framework> | null
) {
  const [form, setForm] = useState<{
    name: string;
    code: string;
    description: string;
  }>({
    name: '',
    code: '',
    description: '',
  });
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [pendingCategories, setPendingCategories] = useState<CategoryInput[]>(
    []
  );
  const [batchStatus, setBatchStatus] = useState<BatchStatus[]>([]);
  const [modalOpen, setModalOpen] = useState(false);
  const [modalStatuses, setModalStatuses] = useState<ModalStatus[]>([]);
  const [currentModalIndex, setCurrentModalIndex] = useState<number>(0);

  // Autofill code and description when name changes
  const handleFormChange = (
    e:
      | React.ChangeEvent<HTMLInputElement>
      | React.ChangeEvent<{ value: unknown }>
      | import('@mui/material/Select').SelectChangeEvent<string>
  ) => {
    const target = e.target as
      | HTMLInputElement
      | { name?: string; value: unknown };
    const name = target.name || '';
    const value = target.value;
    let updatedForm = { ...form, [name]: value };
    if (name === 'name') {
      updatedForm = autoFillCodeFromName(updatedForm, value as string);
      updatedForm.description = autoGenerateDescriptionFromName(
        value as string
      );
    }
    setForm(updatedForm);
  };

  // Add category to local pending list
  const handleAddCategory = (e: React.FormEvent) => {
    e.preventDefault();
    setPendingCategories((prev) => [
      ...prev,
      {
        name: form.name,
        code: form.code,
        description: form.description,
      },
    ]);
    setForm({ name: '', code: '', description: '' });
    setError(null);
    setSuccess(null);
  };

  // Batch create categories with modal
  const handleBatchCreate = async () => {
    setModalOpen(true);
    setBatchStatus([]);
    setModalStatuses(
      pendingCategories.map((cat) => ({
        name: cat.name,
        code: cat.code,
        description: cat.description,
        status: 'pending',
      }))
    );
    setCurrentModalIndex(0);
    const frameworkCode = framework?.code;
    if (!frameworkCode) {
      setModalStatuses(
        pendingCategories.map((cat) => ({
          name: cat.name,
          code: cat.code,
          description: cat.description,
          status: 'failed',
          message: 'Missing framework code',
        }))
      );
      setTimeout(() => {
        setModalOpen(false);
        setBatchStatus(
          pendingCategories.map((cat) => ({
            name: cat.name,
            code: cat.code,
            description: cat.description,
            status: 'failed',
            message: 'Missing framework code',
          })) as BatchStatus[]
        );
        setPendingCategories([]);
      }, 1200);
      return;
    }
    const results = await batchCreateCategories(
      pendingCategories,
      frameworkCode
    );
    // Update store for successful categories
    results.forEach((res, i) => {
      setCurrentModalIndex(i);
      if (res.status === 'success') {
        setCategories([
          ...categories,
          {
            identifier: res.category.code,
            name: res.category.name,
            code: res.category.code,
            description: res.category.description,
            status: 'Live',
          },
        ]);
      }
    });
    setTimeout(() => {
      setModalOpen(false);
      setBatchStatus(
        results.map((res) => ({
          name: res.category.name,
          code: res.category.code,
          description: res.category.description,
          status: res.status,
          message: res.message,
        })) as BatchStatus[]
      );
      setPendingCategories([]);
    }, 1200);
  };

  // Retry a single failed category creation
  const handleRetry = async (idx: number) => {
    if (!batchStatus[idx]) return;
    const cat = batchStatus[idx];
    setBatchStatus((prev) =>
      prev.map((item, i) =>
        i === idx ? { ...item, status: 'pending', message: '' } : item
      )
    );
    const frameworkCode = framework?.code;
    if (!frameworkCode) {
      setBatchStatus((prev) =>
        prev.map((item, i) =>
          i === idx
            ? {
                ...item,
                status: 'failed',
                message: 'Missing framework code',
              }
            : item
        )
      );
      return;
    }
    try {
      await retryCreateCategory(
        {
          name: cat.name,
          code: cat.code,
          description: cat.description,
        },
        frameworkCode
      );
      setCategories([
        ...categories,
        {
          identifier: cat.code,
          name: cat.name,
          code: cat.code,
          description: cat.description,
          status: 'Live',
        },
      ]);
      setBatchStatus((prev) =>
        prev.map((item, i) =>
          i === idx
            ? { ...item, status: 'success', message: 'Successfully created' }
            : item
        )
      );
    } catch (err: unknown) {
      let msg = 'Failed to create category';
      if (err instanceof Error) msg = err.message;
      setBatchStatus((prev) =>
        prev.map((item, i) =>
          i === idx ? { ...item, status: 'failed', message: msg } : item
        )
      );
    }
  };

  const hasUnsavedCategories = () => pendingCategories.length > 0;

  return {
    form,
    setForm,
    error,
    setError,
    success,
    setSuccess,
    pendingCategories,
    setPendingCategories,
    batchStatus,
    setBatchStatus,
    modalOpen,
    setModalOpen,
    modalStatuses,
    setModalStatuses,
    currentModalIndex,
    setCurrentModalIndex,
    handleFormChange,
    handleAddCategory,
    handleBatchCreate,
    handleRetry,
    hasUnsavedCategories,
  };
}
